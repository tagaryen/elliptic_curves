/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdint.h>
#include <gmp.h>
#include <string.h>

#ifndef _Included_com_archer_math_EcPoint
#define _Included_com_archer_math_EcPoint


#ifdef __cplusplus
extern "C" {
#endif
void math_point_mul(mpz_t x, mpz_t y, mpz_t d, mpz_t p, mpz_t a, mpz_t b, mpz_t gx, mpz_t gy) {
  char *bits = mpz_get_str(NULL, 2, d);
  uint32_t len = strlen(bits);
  mpz_t inv, k, tx, ty;
  mpz_init(inv);
  mpz_init(k);
  mpz_init_set(tx, gx);
  mpz_init_set(ty, gy);
  for(int i = 1; i < len; i++) {

    /**double**/ 
    mpz_mul_ui(inv, ty, 2);
    mpz_invert(inv, inv, p);
    mpz_mul(k, tx, tx);
    mpz_mul_ui(k, k, 3);
    mpz_add(k, k, a);
    mpz_mul(k, k, inv);
    mpz_mod(k, k, p);
    //x
    mpz_pow_ui(x, k, 2);
    mpz_sub(x, x, tx);
    mpz_sub(x, x, tx);
    mpz_mod(x, x, p);
    //y
    mpz_sub(y, tx, x);
    mpz_mul(y, y, k);
    mpz_sub(y, y, ty);
    mpz_mod(y, y, p);
    
    mpz_set(tx, x);
    mpz_set(ty, y);
    /**add**/
    if(bits[i] == '1') {

      mpz_sub(inv, tx, gx);
      mpz_invert(inv, inv, p);
      mpz_sub(k, ty, gy);
      mpz_mul(k, k, inv);
      mpz_mod(k, k, p);

      mpz_pow_ui(x, k, 2);
      mpz_sub(x, x, tx);
      mpz_sub(x, x, gx);
      mpz_mod(x, x, p);

      mpz_sub(y, tx, x);
      mpz_mul(y, y, k);
      mpz_sub(y, y, ty);
      mpz_mod(y, y, p);
      
      mpz_set(tx, x);
      mpz_set(ty, y);
    }
  }
  mpz_clear(inv);
  mpz_clear(k);
  mpz_clear(tx);
  mpz_clear(ty);
}

void math_point_add(mpz_t x, mpz_t y, mpz_t x1, mpz_t y1, mpz_t x2, mpz_t y2, mpz_t p) {
  mpz_t t, k;
  mpz_init(t);
  mpz_init(k);

  mpz_sub(t, x1, x2);
  mpz_invert(t, t, p);
  mpz_sub(k, y1, y2);
  mpz_mul(k, k, t);
  mpz_mod(k, k, p);

  mpz_pow_ui(x, k, 2);
  mpz_sub(x, x, x1);
  mpz_sub(x, x, x2);
  mpz_mod(x, x, p);

  mpz_sub(y, x1, x);
  mpz_mul(y, y, k);
  mpz_sub(y, y, y1);
  mpz_mod(y, y, p);

  mpz_clear(k);
  mpz_clear(t);
}


static jclass _curve_cls      = NULL;
static jmethodID _constructor = NULL;
static jfieldID _x            = NULL;
static jfieldID _y            = NULL;
static jfieldID _Gx           = NULL;
static jfieldID _Gy           = NULL;
static jfieldID _P            = NULL;
static jfieldID _N            = NULL;
static jfieldID _A            = NULL;
static jfieldID _B            = NULL;

static mpz_t sm2_p, sm2_a, sm2_b, sm2_gx, sm2_gy, sm2_n;

static mpz_t ec_p, ec_a, ec_b, ec_gx, ec_gy, ec_n;


JNIEXPORT void JNICALL Java_com_archer_math_EcPoint_init
  (JNIEnv *env, jclass jcls) {
    _curve_cls = (*env)->FindClass(env, "com/archer/math/Curve");
    _constructor = (*env)->GetMethodID(env, jcls, "<init>", "()V");
    _x = (*env)->GetFieldID(env, jcls, "x", "[B");
    _y = (*env)->GetFieldID(env, jcls, "y", "[B");
    _Gx = (*env)->GetFieldID(env, _curve_cls, "Gx", "[B");
    _Gy = (*env)->GetFieldID(env, _curve_cls, "Gy", "[B");
    _P = (*env)->GetFieldID(env, _curve_cls, "P", "[B");
    _N = (*env)->GetFieldID(env, _curve_cls, "N", "[B");
    _A = (*env)->GetFieldID(env, _curve_cls, "A", "[B");
    _B = (*env)->GetFieldID(env, _curve_cls, "B", "[B");

    
    mpz_init_set_str(sm2_p, "fffffffeffffffffffffffffffffffffffffffff00000000ffffffffffffffff", 16);
    mpz_init_set_str(sm2_a, "fffffffeffffffffffffffffffffffffffffffff00000000fffffffffffffffc", 16);
    mpz_init_set_str(sm2_b, "28e9fa9e9d9f5e344d5a9e4bcf6509a7f39789f515ab8f92ddbcbd414d940e93", 16);
    mpz_init_set_str(sm2_gx, "32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7", 16);
    mpz_init_set_str(sm2_gy, "bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0", 16);
    mpz_init_set_str(sm2_n, "fffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54123", 16);

    
    mpz_init_set_str(ec_p, "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", 16);
    mpz_init_set_str(ec_a, "0", 16);
    mpz_init_set_str(ec_b, "7", 16);
    mpz_init_set_str(ec_gx, "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", 16);
    mpz_init_set_str(ec_gy, "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", 16);
    mpz_init_set_str(ec_n, "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
}


JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_add
  (JNIEnv *env, jclass jcls, jobject jpoint1, jobject jpoint2, jbyteArray jp) {
    if(NULL == jpoint1 || NULL == jpoint2 || NULL == jp) {
        return NULL;
    }
    jbyteArray jx1 = (*env)->GetObjectField(env, jpoint1, _x);
    jbyteArray jy1 = (*env)->GetObjectField(env, jpoint1, _y);
    jbyteArray jx2 = (*env)->GetObjectField(env, jpoint2, _x);
    jbyteArray jy2 = (*env)->GetObjectField(env, jpoint2, _y);

    uint32_t x1_len = (*env)->GetArrayLength(env, jx1);
    uint32_t y1_len = (*env)->GetArrayLength(env, jy1);
    uint32_t x2_len = (*env)->GetArrayLength(env, jx2);
    uint32_t y2_len = (*env)->GetArrayLength(env, jy2);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);

    uint8_t x1c[x1_len], y1c[y1_len], x2c[x2_len], y2c[y2_len], pc[p_len];

    (*env)->GetByteArrayRegion(env, jx1, 0, x1_len, (jbyte *)x1c);
    (*env)->GetByteArrayRegion(env, jy1, 0, y1_len, (jbyte *)y1c);
    (*env)->GetByteArrayRegion(env, jx2, 0, x2_len, (jbyte *)x2c);
    (*env)->GetByteArrayRegion(env, jy2, 0, y1_len, (jbyte *)y2c);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);

    mpz_t x, y, x1, y1, x2, y2, p;
    mpz_init(x);
    mpz_init(y);
    mpz_init(x1);
    mpz_init(y1);
    mpz_init(x2);
    mpz_init(y2);
    mpz_init(p);

    mpz_import(x1, x1_len, 1, 1, 0, 0, x1c);
    mpz_import(y1, y1_len, 1, 1, 0, 0, y1c);
    mpz_import(x2, x2_len, 1, 1, 0, 0, x2c);
    mpz_import(y2, y2_len, 1, 1, 0, 0, y2c);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    math_point_add(x, y, x1, y1, x2, y2, p);

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(x1);
    mpz_clear(y1);
    mpz_clear(x2);
    mpz_clear(y2);
    mpz_clear(p);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_sub
  (JNIEnv *env, jclass jcls, jobject jpoint1, jobject jpoint2, jbyteArray jp) {
    if(NULL == jpoint1 || NULL == jpoint2 || NULL == jp) {
        return NULL;
    }
    jbyteArray jx1 = (*env)->GetObjectField(env, jpoint1, _x);
    jbyteArray jy1 = (*env)->GetObjectField(env, jpoint1, _y);
    jbyteArray jx2 = (*env)->GetObjectField(env, jpoint2, _x);
    jbyteArray jy2 = (*env)->GetObjectField(env, jpoint2, _y);

    uint32_t x1_len = (*env)->GetArrayLength(env, jx1);
    uint32_t y1_len = (*env)->GetArrayLength(env, jy1);
    uint32_t x2_len = (*env)->GetArrayLength(env, jx2);
    uint32_t y2_len = (*env)->GetArrayLength(env, jy2);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);

    uint8_t x1c[x1_len], y1c[y1_len], x2c[x2_len], y2c[y2_len], pc[p_len];

    (*env)->GetByteArrayRegion(env, jx1, 0, x1_len, (jbyte *)x1c);
    (*env)->GetByteArrayRegion(env, jy1, 0, y1_len, (jbyte *)y1c);
    (*env)->GetByteArrayRegion(env, jx2, 0, x2_len, (jbyte *)x2c);
    (*env)->GetByteArrayRegion(env, jy2, 0, y1_len, (jbyte *)y2c);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);


    mpz_t x, y, x1, y1, x2, y2, p, _0;
    mpz_init(x);
    mpz_init(y);
    mpz_init(x1);
    mpz_init(y1);
    mpz_init(x2);
    mpz_init(y2);
    mpz_init(p);
    mpz_init_set_si(_0, 0);

    mpz_import(x1, x1_len, 1, 1, 0, 0, x1c);
    mpz_import(y1, y1_len, 1, 1, 0, 0, y1c);
    mpz_import(x2, x2_len, 1, 1, 0, 0, x2c);
    mpz_import(y2, y2_len, 1, 1, 0, 0, y2c);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_sub(y2, _0, y2);
    math_point_add(x, y, x1, y1, x2, y2, p);

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(x1);
    mpz_clear(y1);
    mpz_clear(x2);
    mpz_clear(y2);
    mpz_clear(p);
    mpz_clear(_0);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }
    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mul
  (JNIEnv *env, jclass jcls, jbyteArray jd, jint curveId) {
    if(NULL == jd || (curveId != 1 && curveId != 2)) {
        return NULL;
    }
    
    
    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint8_t dc[d_len];
    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);

    mpz_t x, y, d;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);

    mpz_import(d, d_len, 1, 1, 0, 0, dc);

    if(curveId == 2) {
      math_point_mul(x, y, d, sm2_p, sm2_a, sm2_b, sm2_gx, sm2_gy);
    } else if(curveId == 1) {
      math_point_mul(x, y, d, ec_p, ec_a, ec_b, ec_gx, ec_gy);
    } else {
      mpz_clear(x);
      mpz_clear(y);
      mpz_clear(d);
      return NULL;
    }

    // {
    //   printf("x = %s\n", mpz_get_str(NULL, 16, x));
    //   printf("y = %s\n", mpz_get_str(NULL, 16, y));
    // }

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);


    // {
    //   printf("lx = %d\n", lx);
    //   printf("ly = %d\n", ly);
    // }

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulPoint
  (JNIEnv *env, jclass jcls, jbyteArray jd, jint curveId, jobject jpoint) {
    if(NULL == jd || (curveId != 1 && curveId != 2) || NULL == jpoint) {
        return NULL;
    }
    jbyteArray jx = (*env)->GetObjectField(env, jpoint, _x);
    jbyteArray jy = (*env)->GetObjectField(env, jpoint, _y);


    uint32_t x_len = (*env)->GetArrayLength(env, jx);
    uint32_t y_len = (*env)->GetArrayLength(env, jy);
    uint32_t d_len = (*env)->GetArrayLength(env, jd);

    uint8_t xc[x_len], yc[y_len], dc[d_len];

    (*env)->GetByteArrayRegion(env, jx, 0, x_len, (jbyte *)xc);
    (*env)->GetByteArrayRegion(env, jy, 0, y_len, (jbyte *)yc);
    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);

    mpz_t x, y, d, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(gx);
    mpz_init(gy);
    mpz_import(d, d_len, 1, 1, 0, 0, dc);
    mpz_import(gx, x_len, 1, 1, 0, 0, xc);
    mpz_import(gy, y_len, 1, 1, 0, 0, yc);

    if(curveId == 2) {
      math_point_mul(x, y, d, sm2_p, sm2_a, sm2_b, gx, gy);
    } else if(curveId == 1) {
      math_point_mul(x, y, d, ec_p, ec_a, ec_b, gx, gy);
    } else {
      mpz_clear(x);
      mpz_clear(y);
      mpz_clear(d);
      mpz_clear(gx);
      mpz_clear(gy);
      return NULL;
    }
    // math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = 32, ly = 32;
    uint8_t rxc[32], ryc[32];
    mpz_export(rxc, &lx, 1, 1, 0, 0, x);
    mpz_export(ryc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)rxc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)ryc);
    }
    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


/*
 * Class:     com_archer_math_EcPoint
 * Method:    mul
 * Signature: ([BLcom/archer/math/Curve;)Lcom/archer/math/EcPoint;
 */
JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulCurve
  (JNIEnv *env, jclass jpcls, jbyteArray jd, jobject jcurve) {

    if(NULL == jd || NULL == jcurve) {
        return NULL;
    }
    
    jbyteArray jp = (*env)->GetObjectField(env, jcurve, _P);
    jbyteArray ja = (*env)->GetObjectField(env, jcurve, _A);
    jbyteArray jb = (*env)->GetObjectField(env, jcurve, _B);
    jbyteArray jgx = (*env)->GetObjectField(env, jcurve, _Gx);
    jbyteArray jgy = (*env)->GetObjectField(env, jcurve, _Gy);


    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);
    uint32_t a_len = (*env)->GetArrayLength(env, ja);
    uint32_t b_len = (*env)->GetArrayLength(env, jb);
    uint32_t gx_len = (*env)->GetArrayLength(env, jgx);
    uint32_t gy_len = (*env)->GetArrayLength(env, jgy);

    uint8_t dc[d_len], pc[p_len], ac[a_len], bc[b_len], gxc[gx_len], gyc[gy_len];

    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);
    (*env)->GetByteArrayRegion(env, ja, 0, a_len, (jbyte *)ac);
    (*env)->GetByteArrayRegion(env, jb, 0, b_len, (jbyte *)bc);
    (*env)->GetByteArrayRegion(env, jgx, 0, gx_len, (jbyte *)gxc);
    (*env)->GetByteArrayRegion(env, jgy, 0, gy_len, (jbyte *)gyc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    mpz_import(d, d_len, 1, 1, 0, 0, dc);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_import(a, a_len, 1, 1, 0, 0, ac);
    mpz_import(b, b_len, 1, 1, 0, 0, bc);
    mpz_import(gx, gx_len, 1, 1, 0, 0, gxc);
    mpz_import(gy, gy_len, 1, 1, 0, 0, gyc);
    math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = p_len, ly = p_len;
    uint8_t xc[lx], yc[ly];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }
    jobject jobj = (*env)->NewObject(env, jpcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulCurvePoint
  (JNIEnv *env, jclass jcls, jbyteArray jd, jobject jcurve, jobject jpoint) {

    if(NULL == jd || NULL == jcurve) {
        return NULL;
    }
    
    jbyteArray jp = (*env)->GetObjectField(env, jcurve, _P);
    jbyteArray ja = (*env)->GetObjectField(env, jcurve, _A);
    jbyteArray jb = (*env)->GetObjectField(env, jcurve, _B);
    jbyteArray jx = (*env)->GetObjectField(env, jpoint, _x);
    jbyteArray jy = (*env)->GetObjectField(env, jpoint, _y);


    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);
    uint32_t a_len = (*env)->GetArrayLength(env, ja);
    uint32_t b_len = (*env)->GetArrayLength(env, jb);
    uint32_t x_len = (*env)->GetArrayLength(env, jx);
    uint32_t y_len = (*env)->GetArrayLength(env, jy);

    uint8_t dc[d_len], pc[p_len], ac[a_len], bc[b_len], gxc[x_len], gyc[y_len];

    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);
    (*env)->GetByteArrayRegion(env, ja, 0, a_len, (jbyte *)ac);
    (*env)->GetByteArrayRegion(env, jb, 0, b_len, (jbyte *)bc);
    (*env)->GetByteArrayRegion(env, jx, 0, x_len, (jbyte *)gxc);
    (*env)->GetByteArrayRegion(env, jy, 0, y_len, (jbyte *)gyc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    mpz_import(d, d_len, 1, 1, 0, 0, dc);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_import(a, a_len, 1, 1, 0, 0, ac);
    mpz_import(b, b_len, 1, 1, 0, 0, bc);
    mpz_import(gx, x_len, 1, 1, 0, 0, gxc);
    mpz_import(gy, y_len, 1, 1, 0, 0, gyc);
    math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = p_len, ly = p_len;
    uint8_t rxc[lx], ryc[ly];
    mpz_export(rxc, &lx, 1, 1, 0, 0, x);
    mpz_export(ryc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)rxc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)ryc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


#ifdef __cplusplus
}
#endif
#endif
